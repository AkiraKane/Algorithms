# 小盒子的算法题

- [小盒子的算法题](#%e5%b0%8f%e7%9b%92%e5%ad%90%e7%9a%84%e7%ae%97%e6%b3%95%e9%a2%98)
  - [1 二分查找](#1-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be)
  - [2. 二叉树](#2-%e4%ba%8c%e5%8f%89%e6%a0%91)
    - [2.1. 迭代](#21-%e8%bf%ad%e4%bb%a3)
    - [2.2 BFS（层次遍历）](#22-bfs%e5%b1%82%e6%ac%a1%e9%81%8d%e5%8e%86)
    - [2.3 DFS（前序遍历、中序遍历、后序遍历）](#23-dfs%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86)

## 1 二分查找

- [**LeetCode 35 - 搜索插入位置**](src/LC35.java)

    给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
    你可以假设数组中无重复元素。

- [LeetCode 704 - 二分查找](src/LC704.java)

    给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

- [LeetCode 852 - 山脉数组的峰顶索引](src/LC852.java)

    给定一个确定为山脉的数组，返回唯一一个满足 A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1] 的 i 的值。

## 2. 二叉树

### 2.1. 迭代

- [**LeetCode 94 - 二叉树的中序遍历**](src/LC94.java)

    给定一个二叉树，返回它的中序遍历。
    
    思路：用栈模拟系统。尽可能的压左边的节点进栈，没左边节点可压时，就可以打印栈顶节点并向右节点进发了。

- [**LeetCode 144 - 二叉树的前序遍历**](src/LC144.java)

    给定一个二叉树，返回它的前序遍历。

    思路：用栈模拟系统。后进先出，所以先右后左。
    
- [**LeetCode 145 - 二叉树的后序遍历**](src/LC145.java)

    给定一个二叉树，返回它的后序遍历。

### 2.2 BFS（层次遍历）

- [LeetCode 102 - 二叉树的层次遍历](src/LC102.java)

    给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

- [LeetCode 103 - 二叉树的锯齿形遍历](src/LC103.java)

    给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

- [LeetCode 199 - 二叉树的右视图](src/LC199.java)

    给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

### 2.3 DFS（前序遍历、中序遍历、后序遍历）

- [**LeetCode 98 - 验证二叉搜索树**](src/LC98.java)

    给定一个二叉树，判断其是否是一个有效的二叉搜索树。

- [LeetCode 105 - 前序遍历和中序遍历序列构造二叉树](src/LC105.java)

    根据一棵树的前序遍历与中序遍历构造二叉树。

- [LeetCode 106 - 中序和后序遍历序列构造二叉树](src/LC106.java)

    根据一棵树的中序遍历与后序遍历构造二叉树。

- [LeetCode 226 - 翻转二叉树](src/LC226.java)

    翻转一棵二叉树。

- [LeetCode 235 - 二叉搜索树的最近公共祖先](src/LC235.java)

    给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

- [**LeetCode 236 - 二叉树的最近公共祖先**](src/LC236.java)

    给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

- [LeetCode 617 - 合并二叉树](src/LC617.java)

    给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

- [**LeetCode 938 - 二叉搜索树的范围和**](src/LC938.java)

    给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。

- [**LeetCode 1379 - 找出克隆二叉树中的相同节点**](src/LC1379.java)

    给你两棵二叉树，原始树 original 和克隆树 cloned，以及一个位于原始树 original 中的目标节点 target。

